# 八股

## 计算机网络

### GET和POST

GET是从服务器获取指定的资源，POST是跟去请求负荷对指定的资源做出处理。

* GET方法是安全且幂等的。
* POST是不安全不幂等的。

### HTTP和HTTPS的区别

HTTP存在窃听、篡改和冒充的风险。

HTTPS具有信息加密、校验机制、身份证书。

HTTP是超文本传输协议，明文传输，HTTP默认端口为80，HTTPS默认端口为443

### HTTPS握手过程

TLS第一次握手

* 由客户端向服务器发起加密通信请求，也就是ClientHello请求。客户端向服务器发送TLS协议版本，客户端生产的随机数，后面作为会话密钥的条件之一，RSA加密算法

TSL第二次握手

* 服务器收到客户端请求后，向客户端发出响应，也就是SeverHello

TSL第三次握手

* 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的CA公钥确认证书的真实性，如果没有问题，就从数字证书中取出服务器公钥，使用它来加密报文。

TSL第四次握手

* 服务器收到客户端的第三个随机数后，通过协商的加密算法，计算出本次的会话密钥，然后发信息。

### HTTPS如何防范中间人的攻击

* 加密
* 身份验证

### HTTP、SOCKET、TCP的区别

* HTTP是应用层协议，用于在客户端和服务器之间传输和显示Web页面。
* SOCKET是通信的一端，提供了网络通信的接口，可实现不同计算机之间的数据交换
* TCP是一种面向链接的可靠传输层协议。端与端之间建立可靠的数据传输链接。

### cookie和session的区别

* cookie存储在客户端(通常是浏览器)。当浏览器向服务器发出请求时，会自动附带cookie的数据。
* Session存储在服务器端，服务器为每一个用户分配一个唯一的Session ID。
* Session比Cookie大
* Cookie不安全，容易收到XSS（跨站脚本攻击）和CSRF（跨站请求伪造）的攻击
* cookie过期自动删除，Session是用户在关闭浏览器时删除

### 客户端禁用了Cookie，Session还能用吗

默认情况下禁用Cookie后，Session是无法正常使用的。

### localStorage与Cookie

* localstorage的存储较大，如果需要存储大量数据，localstorage比cookie更合适
* localstorage仅在浏览器端存储数据，所以，它更适合在同一域名下的不同页面之间共享数据
* cookie可以设置一个过期时间，而local storage的数据永远保存在浏览器中，除非手动使用js删除
* localstorage在浏览器中存储，不会发送到服务器，不存在窃听和篡改的风险，比cookie安全。

### JWT令牌和传统方式有什么区别

* JWT是无状态的令牌，不需要在服务器端存储会话信息，JWT令牌中包含了用户身份、权限等信息，方便进行扩展和跨域访问
* JWT比cookie钢架安全，有效防止了CSRF（跨站请求伪造）等攻击
* JWT跨域在不同域之间传递，适合跨域访问的场景。通过在请求的头部或参数中携带JWT令牌，实现无需Cookie的跨域身份验证。

### JWT令牌有哪些字段

头部、载荷、签名

### JWT的缺点

一旦发出，无法撤销

可以用redis维护一个黑名单，想让这个JWT失效，就把这个JWT加入黑名单中，然后每次使用JWT进行请求的时候，都先判断这个JWT是否在黑名单中。

### 前端如何存储JWT

JSON WEB TOKEN

所有数据都保存在客户端，每次请求都发回服务器，JWT就是这样的方案的一个代表，

客户端收到服务器返回的JWT，可以存储在local storage里面，也可以存储在Cookie里面，还可以存储在Session Storage里面。

* local storage（本地存储）

存储空间大，不会出现在HTTP缓存或日志中

但存在XSS（跨站脚本攻击）的风险

* Session storage（会话存储）

浏览器关闭，数据就会清除，减少了数据泄露的风险。

用户刷新页面就要重新登录

* Cookie

可以设置HttpOnly来防止js访问，减少XSS攻击的风险

每次HTTP请求都要携带Cookie，会影响性能，可能遭受CSRF（跨站请求伪造）攻击

### HTTP长连接和WebSocket有什么区别

WebSocket是全双工的，HTTP可以使用定时轮询或者长轮询的方式实现服务器推送效果。客户端和服务器需要频繁交互的场景，可以使用WebSocket协议

### TCP三次握手

客户端向服务端发送连接请求，SYN=1

服务端收到客户端的SYN报文后，SYN和ACK=1，发送给客户端，同意连接

客户端收到服务端报文后，向服务端发送最后一个应答报文，最后把报文发送给服务端。

第三次握手是可以携带数据的，前两次握手时不可以携带数据的！

### 为什么要三次握手

防止【历史连接】初始化了连接，如果是两次握手，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费

### TCP四次挥手

第一次挥手 客户端发出连接释放报文，并且停止发送数据。此时，客户端进入FIN-WAIT-1（终止等待1）状态

第二次挥手 服务器端接收到连接释放报文后，发出确认报文，此时，服务端就进入了CLOSE-WAIT 关闭等待状态

第三次挥手 客户端接收到服务器端的确认请求后，等待服务器发送连接释放报文，**服务器将最后的数据发送完毕后**，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成

### HTTP长连接机制

使用同一个TCP连接来发送和接受多个HTTP请求或者应答，避免了建立连接和释放的开销。

在HTTP1.0中默认关闭，在header中添加：`Connection:Keep-Alive` ，这样，TCP连接就不会中断，而是保持连接，当客户端发送另一个请求时，他会使用同一个TCP连接

## 操作系统

### 死锁

互斥，不可剥夺，循环等待，让权等待

## JAVA基础

### JAVA的特点

* 平台无关性：编写一次，处处运行
* 面向对象：
* 内存管理：垃圾回收机制，自动管理内存和回收不需要用的对象

### JAVA为什么是跨平台的

JVM是一个桥梁，是一个“中间件”，是实现跨平台的关键，java代码首先被编译成字节码文件，再有JVM将字节码文件翻译成特定平台下的机器码然后运行。

### 装箱和拆箱是什么

是将基本数据类型和对应的包装类之间进行转换的过程

### 面向对象的理解

* 封装
* 继承
* 多态：允许不同类的对象对同一消息做出响应，即同一接口，使用不同的实例而执行不同的操作，分为编译时多态（重载）和运行时多态（重写），是程序具有良好的灵活性和扩展性

### 多态体现在那几个方面

* 重载：一个类中有同名方法，但参数列表不一样
* 重写
* 接口与实现：多个类可以实现同一个接口。
* 向上转型和向下转型

### 面向对象的设计原则

* 单一职责原则
* 开放封闭原则
* 里氏替换原则
* 接口隔离原则
* 依赖倒置
* 最少知识原则

### 抽象类和普通类的区别

* 普通类可以直接实例化，抽象类只能被继承
* 普通类中的方法有具体的实现，而抽象类的方法可以实现可以不实现
* 一个类可以继承一个普通类，可继承多个接口，而一个类只能继承一个抽象类，但可以同时实现多个接口
* 抽象类一般被用作基类，被其他类扩展和继承使用

### 抽象类

不能被final修饰

不能实例化

### 深拷贝和浅拷贝

* 浅拷贝：只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段，浅拷贝只是创建了一个新的对象，然后把值复制进去。
* 深拷贝：递归复制对象内容的所有引用类型的字段，生成一个全新的对象以及内部的所有对象。

### 实现深拷贝的三种方法

* 实现Cloneable接口并重写clone（）方法
* 使用序列化和反序列化
* 手动递归复制

### Java创建对象的方式

* new
* class类的newInstance（）
* Constructor类的newInstance（）方法
* clone（）方法
* 反序列化

### 反射

在运行状态中，对于任何一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能就是反射机制

特性：

* 运行时类信息访问
* 动态对象创建
* 动态方法调用
* 访问和修改字段值

### 注解的原理

本质上是继承了一个Annotation的特殊接口，其具体实现类是java运行时生成的动态代理类。

### 注解的作用域

* 类级别作用域
* 方法级别作用域
* 字段级别作用域

### 锁

乐观锁和悲观锁是两种常见的并发控制策略，它们在处理并发数据访问时的基本假设和处理方式有所不同。

### 乐观锁（Optimistic Locking）

1. **基本假设**：乐观锁假设大多数情况下数据是不会发生冲突的，因此在数据读取时不会加锁。

2. **实现方式**：乐观锁通常通过在数据表中增加一个版本号或时间戳字段来实现。当读取数据时，会记录当前的版本号，在更新数据时检查版本号是否发生变化。如果版本号未变化，则更新数据并增加版本号；如果版本号已变化，表示数据在此期间已被其他事务修改，更新操作将被拒绝。

3. **优点**：
   - **并发性高**：由于读取数据时不加锁，因此不会阻塞其他事务读取数据，提高了系统的并发能力。
   - **开销小**：在没有冲突的情况下，乐观锁通常只需要很少的资源开销。

4. **缺点**：
   - **重试机制**：当更新失败时，需要实现重试机制，可能需要回滚事务，增加了程序的复杂性。
   - **适用场景有限**：在冲突非常频繁的场景下，频繁的重试可能会导致性能问题。

### 悲观锁（Pessimistic Locking）

1. **基本假设**：悲观锁假设数据在大部分时间可能会发生冲突，因此在数据读取时就进行加锁，直到事务完成。

2. **实现方式**：悲观锁通常通过数据库提供的锁机制实现，如SELECT ... FOR UPDATE语句，它会在读取数据时锁定数据行，直到事务提交或回滚。

3. **优点**：
   - **数据一致性**：由于在读取时就加锁，可以有效防止并发事务对同一数据的修改，保证了数据的一致性。
   - **简单易用**：不需要额外的版本号字段，也不需要处理更新失败的重试逻辑。

4. **缺点**：
   - **并发性低**：加锁会阻塞其他事务的读取操作，降低了系统的并发能力。
   - **开销大**：长时间持有锁可能会导致资源浪费，增加系统的开销。

### 对比总结

- **冲突假设**：乐观锁假设冲突发生概率较低，悲观锁假设冲突发生概率较高。
- **资源开销**：乐观锁在冲突少的情况下资源开销小，悲观锁在冲突多的情况下可能更高效。
- **并发性能**：乐观锁并发性能通常优于悲观锁，因为它不会阻塞读取操作。
- **实现复杂度**：乐观锁需要处理冲突检测和重试逻辑，悲观锁则依赖数据库的锁机制。

在选择乐观锁还是悲观锁时，需要根据具体的应用场景、数据冲突的频率和系统对并发性能的要求来决定。

## MYSQL

### NOSQL和SQL的区别

关系型数据库支持ACID即原子性、一致性、隔离性、持久性

NOSQL采用更加宽松的模型BASE，即基本可用，软状态和一致性

NOSQL数据直接无关系，容易扩展

## Redis

### Redis 的数据类型

Redis足一个开源的高性能键值在系统具有快速员活持久化、多种数据结构支持等特点南用缓府,消息队到,计数器等场景。五种数据美型:string,hash,list.setl集合)及zset (有序集合)

### Redis是单进程单线程的

redis是单进程单线程的，redis 利用队列技术将并发访河变为串行访间，消除了传统数据库串行控制的开销。

### Redis 持久化机制,各自优缺点

1、RDB (Redis DataBase)持久化方式,是指用数据集快照的半持久化模式，记录redis数据库的所有特建值对,在某个时间点将数据写入一个临时文件,持久化结束后,用这个临时文件替拱上次持久化的文件,达到数据恢复。
优:只有一个文件 dump.rdb,方便持久化，容灾性好，相对数据集大时,比AOF的启动效率更高。
缺:数据安全性低:RDB是间隔一段时间进行持久化，如果持久化之间reids发生故障，会发生数据丢失。
2、AOF(Append-only file)持久化方式:是指所有的命令行记录以redis命令清求协议的格式完全持久化在储，保存为AOF文件。
优:数据安全,每进行一次命令操作就记录到aof文件中一次。通append模式写文件即使中途服务器宕机可以通过redis-check-aof工具解决数据一致性问题。AoF的rewrite 模式

缺:AOF文件比RDB文件大且恢复速皮慢。数据集大时,比rdb启动效争低。

### Redis 过期键的删除策略

1. 定时册除,在没置争建的过期时间的同时,创建一个定时期器,让文时男在年建过期时间来临时,立即执行对年建的册非余操作。
2. 情性删除,放任键过期不管,但是每次从键空间中获取键时,都能查取得的键是否过期,如果过期的话,就删除该键;如果没过期,就返回该键
3. 定期删除:每隔一段时间程序就对数据库进行一次检查,删除里面的过期键，至于要删除多少过期键,以以及要检查多少个数据库,则由算法决定。

### Redis的回收策略

LRU (Least Recently send)最近最少便用策略,根据键最近被访间的时间来淘汰最久未使用的键。 常用保留最常用数据的场景

LFu (Least Frequently Used)最不经常使用策略,适用于保留最常用数据的场景

Random (随机策略),适用于数据淘达没有要求的场景

TTL (Time to Live)基于键的过期时间来淘汰键。保留最晚过期的数据

Maxmemory-policy(最大内存策略):当达到最大内存限制时,根据配置的策略来淘汰键,常见的策略有的noeviction（不淘汰,拒绝写入)、allkeys-lru(所有键中最近最少使用的键)

### redis的同步机制

Redis的同步机制包括主从复制和哨兵机制
主从复制可以将一个Red;实例(主节点)的数据复制到其亡的价奖例上,都点负责处理写操作,而以节点负费复制主节点的数据,并上理读清求,让从复制是高系统的可扩展性、开性和数据见余性。

## Mybatis

### 什么是mybatis

mybatis是一个半ORM（对象关系映射）框架，内部封装了JDBC

### mybatis缺点

SQL编写工作量大，依赖于数据库，移植性差，不能随意更换数据库

### #{}和${}的区别

{}是预编译处理，${}是字符串替换。

/#{}会将sql替换为？号，调用preparestatement的set方法来赋值

可以有效防止SQL注入

### Mybatis是如何进行分页的，分页插件的原理是什么

mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页

分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL，根据dialect方言，添加对应的物理分页的语句和参数

### Mybbatis的一级二级缓存

一级缓存：基于perpetualcache的HashMap本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有cache就将被清空，默认打开一级缓存

二级缓存：与一级缓存机制相同，不同在于其存储作用域为Mapper（namespace），要打开耳机缓存，使用二级缓存属性需要实现serializable序列化接口，可在他的映射文件中配置cache

## ElasticSearch

### 什么是es

是一个开源的分布式搜索和分析引擎，用于快速、可扩展和实时地搜索、分析和存储大规模数据，它支持全文搜索，多种数据类型、分布式架构和RESTful API等关键特性

### es的倒排索引是什么

倒排索引是通过分词策略，形成了词和文章的映射关系型，这种词典+映射表即为倒排索引

底层是基于FST数据结构，

优点是：

* 空间占用少，通过对词典中单词前缀和后缀的重复利用，压缩了存储空间
* 查询速度快，0（len(str)）的时间复杂度

### es调优

* 增加硬件配置
* 合理设置分片和副本
* 优化索引设计：避免不必要的字段和复杂的数据结构。
* 使用合适的分词器和分析器，以及合理的索引设置
* 使用合适的查询类型和语法，避免过度使用全文搜索，使用过滤器、聚合和缓存技术来减少查询的计算量和响应时间
* 调整JVM参数，如内存大小、垃圾回收策略，根据数据量调整集群规模

### es索引文档的过程

1. 解析查询：把请求转换为内部的查询数据结构
2. 查询分发：ES确定包含查询词的分片，并将查询请求转发到响应的分片上处理
3. 倒排索引匹配：查询包含查询词的倒排索引条目，并获取相关的文档ID
4. 文档评分：根据文档与查询的匹配度计算得分
5. 结果合并：协调节点将来自不同分片的结果进行合并，并根据结果得分排序
6. 返回结果

### ES部署优化

1. 关闭缓存 swap ： swapoff
2. 虚拟内存设置，修改etc/sysctl.conf文件中的vm.max_map_count参数来增加虚拟内存限制
3. 根据业务需要调整线程池和队列大小

### ES更新和删除文档的过程

删除和更新都是写操作，但是ES中的文档是不可变的，因此不能被删除或改动

磁盘上每个段都有一个响应的del文件，当删除请求发送后，文档并没有删除，而是在del文件中被标记为删除。该文档依然能够匹配查询，但是会在结果中被过滤。当段合并时，在del文件中被标记为删除的文档将不会被写入新段。

当新文档被创建时，es会为该文档指定一个版本号，当执行更新时，旧版本的文档在del文件中被标记为删除，新版本的文档被索引到了一个新段，旧版本的文依然能够匹配查询，但时会在结果中被过滤掉

### lucence

lucence是一个开源的全文搜索引擎，es是基于lucence构建的分布式搜索和分析引擎，主要功能包括：文本分析，倒排索
引，查询解析.相似度评分，除了基本的搜索和索引功能，Lucence还提供了排序，过滤、聚合，分页等。

### Es对于大数据量的聚合如何实现？

1.分析和复制，ES将索引数据分成多个分片，并在集群中的多个节点上进行复制。这样可以将数据分散存储和处理提行性和吞吐量。当E进行聚合操作时，E可以同时在多个分片上进行聚合计算，然后将结果合并.
2.聚合桶缓存：ES使用聚合桶来加速聚合操作。聚合桶将聚合操作分为多个子聚合，并在每个分片上执行子聚合计算，然后将结果合并，可以实现更高效的聚合操作
3.、分布式聚合：ES支持分布式器合，即将聚合操作分散到了多个节点上执行，通过聚合操作分解为多个子聚合，并在每个分片上执行子聚合计算，然后将结果合并。可以实现更高效的聚合
4、聚合优化：近似聚合：在牺牲一定精确性的情况下，大幅提高聚合性能.
当并没有 预聚合：提前计算和缓存聚合结果，以加速后续操作.

### ES中的聚合以及其含义？

不会说 在ES中，聚合(aggregation)是一种用于数据分析和汇总的功能。它可以对索
引中的数据进行统计、分组、计算指标等操作，以便从数据中提取有价值
执行是 桶聚合：将文档分组到不同的桶中，每个桶代表一个特定的条件或范围。引上 指标聚合：计算某个字段的统计指标，如求和、平均值、最大值等。
矩阵聚合：用于计算多个字段间的关联性和统计信息。
嵌套聚合：允许在聚合结果上进行进一步的嵌套聚合操作，以实现更复杂的数据分析需求

聚合管道：允许按照一系列的聚合操作顺序执行

通过组合和嵌套不同类型的聚合，可以实现灵活和多样化的数据分析和汇总操作。聚后结果可以以结构化的形式返回，方便后读的数据处理和展示。

### 在并发的情况下.ES如何保证读写一致性

1.分布式事务：Es本身不支持跨当个文档或多个索引的分布式事务。但是，对于个文档的读写，ES提供了乐观并发控制机制。每个文档都有一个，version字段用于标识文档的版本。当多个并发写操作发生时，ES会检查版本号，如果版本号不匹配，则会拒绝写入操作，从而保证写操作的一致性。
2.索引刷新和刷新策略：ES使用了近实时的索引刷新机制。当文档被索引或更新后，它不会立即对外可见，而是会在一定时间间隔内进行刷新操作，默认情况下，ES每秒自动刷新一次。这样可以保证在并发写入的情况下，读取操作能够获取到最新的数据。
3、分片级别的一致性：ES将索引数据分成多个分片，并在多个节点上进行复制。当进行写入操作时，ES会将写入请求发送到主分片，并将写入操作复制到副分片。只有当主分片和副本分片都写入成功后，写入操作才会返回成功，这样可保证写入操作的一致性